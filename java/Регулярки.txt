	java.util.regex, 
		который состоит из трёх классов.
Классы, которые позволяют сравнить текстовую строку, с указанным шаблонным регулярным выражением.
Регулярные выражения (англ. regular expressions, жарг. регэкспы или регексы) ? 
современная система поиска текстовых фрагментов в электронных документах, основанная на специальной системе записи образцов для поиска.
	
Рассмотрим классы, используемые в работе с регулярными выражениями:
- Pattern - скомпилированное представление регулярного выражения.
- Matcher - движок, который проводит операции сравнения между шаблоном (регулярным выражением) и указанной строкой.
- PatternSyntaxException - исключение генерируемое в случае синтаксических ошибок в регулярном выражении.

	Итак, как уже было сказано выше, для того, что-бы использовать регулярное выражение (класс Pattern), 
мы вначале должны задать его с помощью строки, потом скомпилировать эту строку путём вызова статистического 
метода compile() класса Pattern. В результате мы получаем готовое для работы регулярное выражение.
Для сравнения строки с регулярным выражением используем метод matcher() класса Matcher. Проверить результат сравнения можно
с помощью метода matches() этого же класса.

Рассмотрим простой пример
Pattern p = Pattern.compile("1*0");
Matcher m = p.matcher("111110");
boolean b = m.matches(); 

Как видим в первой строке создаётся регулярное выражение, которое соответствует строке любой длинны, 
которая должна начинатся из последовательности единицц и должна заканчиваеться нулём. 
Во второй строке сравниваем наше регулярное выражение с указанной строкой. 
В результате сравнения переменная b в третьей строке примет значение true.

Рассмотрим найболее часто встречаемые конструкции регулярный выражений:

\\ - обратный слеш
\t - символ табуляции
\n - переход на новую строку
\r - возврат каретки
\e - символ Esc
\0n - символ в восьмиричной системе отсчёта 0n (0<=n<=7) 
\xhh - символ в 16-ричной системе отсчёта 0xhh
\uhhhh - символ в 16-ричной системе отсчёта 0xhhhh

[150] - символ может принимать значение 1 , 5 либо 0
[^45] - символ может принимать любые значения, кроме 4 и 5
[0-9_a-z] - символ может принимать значение от 0 до 9 ЛИБО от a до z
[1-9&&[^4-6]] - символ может принимать значения от 1, до 9, кроме 4,5, 6.

. - любой символ
\d - цифра от 0 до 9: [0-9]
\D - не цифра : [^0-9]
\s - символ "пробела" : [ \t\n\x0B\f\r]
\S - [^\s]
\w - литера английского алфавита либо цифра A word character: [a-zA-Z0-9]
\W - [^\w]

X* - соответствует любому количеству (даже нулевому) последовательно идущих символов X
		Причём с таким шаблоном совпадёт и пустая строка.
X? - символ Х встречается один раз или ни разу
X+ - символ Х встречается один или более раз
X{n} - символ Х встречается в точности n раз
X{n,} - символ Х встречается не меньше n раз
X{n,m} - символ Х встречается не меньше n раз, но не больше m раз

Это далеко не полный перечень регулярных конструкций, которые могут использоватся для распознавания строк.
С учётом рассмотренных регулярных конструкций попробуем написать функцию, которая с помощью регулярных выражений будет распознавать правильность ввода электронного адреса:

public static boolean testEmail(String email){
Pattern p = Pattern.compile("(([a-zA-Z][\\w]*)@[\\w[.]]*\\.+([a-z]+))");
Matcher m = p.matcher(email);
boolean b = m.matches();
return b;
}
Итак, каждый электронный адрес должен начинатся из символа латинского алфавита, 
а после могут следовать другие символы латинского алфавита, либо цифри, хотя их может и не быть (логин длинной 1 тоже допустим). 
Обезательный символ комерческае Эт (собачка). И последняя часть доменное имя: слова в перемешку с цифрами разделенные точками, 
и заканчивающееся 2мя либо тремя буквами латинского алфавита (ru, ua, com , net и т.д.).

Pattern.compile(“[a-zA-Z]{1}[a-zA-Z\\d\\u002E\\u005F]+@([a-zA-Z]+\\u002E){1,2}((net)|(com)|(org))”);

Последовательность вида [a-zA-Z] указывает на множество. {n} говорит о том, что некоторый символ должен встретится n раз,
 а {n,m} - от n до m раз. Символ \d указывает на множество цифр. “\u002E” и “\u005F” - это символы точки и подчеркивания соответсвенно. 
 Знак плюс после некоторой последовательности говорит о том, что она должна встретится один или более раз. 
 “|” - представление логического “или”. Полное описание всех конструкций можно найти в Java API.

Разбиваем строку для поиска на отдельные лексемы
	public void setWord(String mWord){
		Pattern p = Pattern.compile("\\s+");
		this.words = p.split(mWord.toUpperCase().trim());
				
		} 